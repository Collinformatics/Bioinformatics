# Use a Hidden Markov Model to compute the most likly state sequnece of a protein
    # States: Soluble (S) or Transmembrane (T)


import numpy as np
import pandas as pd
import sys


protein = 'KNSFFFFFFFLIII'
fileSeqState = 'seqState.txt'
fileSeqSoluble = 'seqSoluble.txt'
fileSeqMembrane = 'seqTransmembrane.txt'
printData = True


def loadSeq(path, catSeqs):
    with open(path, 'r') as file:
        if catSeqs:
            # Load sequeces as one long string
            loadedSeq = file.read().replace('\n', '')
            loadedSeqLen = len(loadedSeq)
            if printData:
                print(f'File: {path}\n'
                      f'Sequence length: {loadedSeqLen:,}')
            return loadedSeq, loadedSeqLen
        else:
            # Load sequeces as individual strings
            loadedSeq = file.read().strip().split('\n')
            if printData:
                print(f'File: {path}\n'
                      f'Sequence length: {loadedSeqLen:,}')
            return loadedSeq


def transitionProb(fileName):
    # Load sequences
    seq, totalAA = loadSeq(path=fileName, catSeqs=True)

    # Calculate: Counts AA
    counts = {}
    for AA in seq:
        if AA in counts.keys():
            counts[AA] += 1
        else:
            counts[AA] = 1

    # Calculate: Frequency AA
    frequency = {AA: count / totalAA for AA, count in counts.items()}
    frequency = sorted(frequency.items())
    if printData:
        print('Amino Acid Frequency:')
        for index in range(0, len(frequency), 2):
            AA1, freq1 = frequency[index]
            if index + 1 < len(frequency):
                AA2, freq2 = frequency[index + 1]
                print(f'     {AA1}: {freq1:.6f}     {AA2:}: {freq2:.6f}')
            else:
                print(f'     {AA1}: {freq1:.6f}')
    frequency = dict(frequency)

    # Calculate: Counts digram
    countsDigram = {}
    for index in range(totalAA):
        if index == totalAA-1:
            break
        digram = seq[index:index+2]
        if digram in countsDigram.keys():
            countsDigram[digram] += 1
        else:
            countsDigram[digram] = 1
    printCounts = True
    for digram in countsDigram.keys():
        if digram[0] not in ['S', 'T'] or digram[1] not in ['S', 'T']:
            printCounts = False
            break

    # Calculate: Frequency AA
    frequencyDigram = {digram: count / totalAA for digram, count in countsDigram.items()}
    if printData:
        if fileName == fileSeqState:
            print(f'\nDigram: Frequency')
            for digram, freq in frequencyDigram.items():
                print(f'     {digram}: {freq}')

    # Calculate: Transmission probabilites
    transitionMatrix = pd.DataFrame()
    totalTransitionFreq = {}
    for digram, freq in frequencyDigram.items():
        AA1 = digram[0]
        AA2 = digram[1]
        if AA1 in totalTransitionFreq.keys():
            totalTransitionFreq[AA1] += freq
        else:
            totalTransitionFreq[AA1] = freq
    for digram, freq in frequencyDigram.items():
        AA1 = digram[0]
        AA2 = digram[1]
        transitionMatrix.loc[AA1, AA2] = freq / totalTransitionFreq[AA1]
    if printData:
        print(f'\nTransition Probabilities:\n'
              f'{transitionMatrix}\n\n')

    return transitionMatrix


def emissionProb(filePathSoluble, filePathMembrane):
    # Load sequences
    seqSolu = loadSeq(path=filePathSoluble, catSeqs=False)
    seqMem = loadSeq(path=filePathMembrane, catSeqs=False)

    # Calculate: Counts AA
    countsSolu = {}
    totalAASolu = 0
    countsMem = {}
    totalAAMem = 0
    for seq in seqSolu:
        for AA in seq:
            totalAASolu += 1
            if AA in countsSolu.keys():
                countsSolu[AA] += 1
            else:
                countsSolu[AA] = 1
    for seq in seqMem:
        for AA in seq:
            totalAAMem += 1
            if AA in countsMem.keys():
                countsMem[AA] += 1
            else:
                countsMem[AA] = 1

    # Calculate: Frequency AA
    frequencySolu = {AA: count / totalAASolu for AA, count in countsSolu.items()}
    frequencySolu = sorted(frequencySolu.items())
    frequencyMem = {AA: count / totalAAMem for AA, count in countsMem.items()}
    frequencyMem = sorted(frequencyMem.items())
    if printData:
        print('Amino Acid Frequency:')
        for index in range(0, len(frequencySolu), 2):
            AA1, freq1 = frequencySolu[index]
            if index + 1 < len(frequencySolu):
                AA2, freq2 = frequencySolu[index + 1]
                print(f'     {AA1}: {freq1:.6f}     {AA2:}: {freq2:.6f}')
            else:
                print(f'     {AA1}: {freq1:.6f}')
        print('\n')
        for index in range(0, len(frequencyMem), 2):
            AA1, freq1 = frequencyMem[index]
            if index + 1 < len(frequencyMem):
                AA2, freq2 = frequencyMem[index + 1]
                print(f'     {AA1}: {freq1:.6f}     {AA2:}: {freq2:.6f}')
            else:
                print(f'     {AA1}: {freq1:.6f}')
    frequencySolu = dict(frequencySolu)
    frequencyMem = dict(frequencyMem)

    aminoAcids = set(frequencySolu.keys()).union(set(frequencyMem.keys()))
    emissionProb = {AA: {
        "S": frequencySolu.get(AA, 0), # P(AA | S)
        "T": frequencyMem.get(AA, 0) # P(AA | T)
    } for AA in aminoAcids}

    # Convert to df
    emissionProbDF = pd.DataFrame(emissionProb).T.sort_index()
    if printData:
        print(f'\nEmission Probability Matrix:\n'
              f'{emissionProbDF.map(lambda x: f'{x:.3f}')}\n\n'
              f'Sum: {sum(emissionProbDF.iloc[:,0])}    {sum(emissionProbDF.iloc[:,1])}')

    return emissionProbDF


def viterbi(proteins, transitionMatrix, emissionMatrix, states):
    # if printData:
    print(f'Viterbi Algorithm:\n'
          f'     States: {states}\n\n'
          f'Transition Probabilities:\n{transitionMatrix}\n\n'
          f'Emission Probabilities:\n{emissionMatrix}\n')

    seqStates = []
    for seq in proteins:
        seqLen = len(seq)

        # V[i][j] stores the highest probability at position i with state j
        V = np.zeros((seqLen, len(states)))
        backpointer = np.zeros((seqLen, len(states)),
                               dtype=int)  # backpointer for backtracking

        # Initial probabilities for the first amino acid
        for indexState, state in enumerate(states):
            V[0, indexState] = (emissionMatrix[state].get(seq[0], 0) *
                                (1 / len(states)))

        # Fill in the path matrix (V)
        for index in range(1, seqLen):
            for indexState, state in enumerate(states):
                probMax = -1  # Maximum probability
                stateMax = -1  # State with the maximum probability
                for indexStatePrev, statePrev in enumerate(states):
                    prob = (V[index - 1, indexStatePrev] *
                            transitionMatrix[statePrev][state] * \
                            emissionMatrix[state].get(seq[index], 0))
                    if prob > probMax:
                        probMax = prob
                        stateMax = indexStatePrev

                V[index, indexState] = probMax
                backpointer[index, indexState] = stateMax

        # Find the most likely sequence of states
        sequence = ''
        statePrev = np.argmax(V[seqLen - 1])
        sequence += states[statePrev]

        # Backtrack through the Viterbi matrix
        for index in range(seqLen - 2, -1, -1):
            statePrev = backpointer[index + 1, statePrev]
            sequence += states[statePrev]
        seqStates.append(sequence)

    for index in range(len(proteins)):
        print(f'Sequence: {proteins[index]}\n'
              f'State Sequence: {seqStates[index]}\n')


# Evaluate training and experimantal data
freqTransition = transitionProb(fileName=fileSeqState)
emissionProbabilities = emissionProb(filePathSoluble=fileSeqSoluble,
                                     filePathMembrane=fileSeqMembrane)

# Predict states
viterbi(proteins=[protein],
        transitionMatrix=freqTransition,
        emissionMatrix=emissionProbabilities,
        states=['S', 'T'])
